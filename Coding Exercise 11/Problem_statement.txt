Extending Compute GPA Exercise with Exceptions

In this simple exercise we extend the Compute GPA exercise that was part of section 4. If you have not done that exercise, then you should review that problem description and understand the below code, which is the solution for that exercise. In this exercise, we will mainly test: (a) creating custom exceptions with attributes & throwing them and (b) exception chaining. This exercise should make you comfortable with different aspects of exceptions including creating your own. It is a straightforward exercise, if all the lectures have been followed clearly. So, if you are having any trouble implementing it, pls. do review the lectures once again.

Below is the solution for that exercise and you may recall that it had two methods: calculateGPA & getStudentsByGPA where getStudentsByGPA internally invokes calculateGPA. Following are specific tasks.

Task 1: In calculateGPA(), studentsGrades parameter has grades corresponding to students in studentIdList, i.e., there is one-to-one correspondence. So, you cannot have something like below where grades of one of the students is missing. From this data it is not clear whether the given grades is of student with id 1001 or 1002. Such an inconsistency should be reported immediately as passing such data is a programming flaw, which means it would be ideal to report it as a RuntimeException. So, if the sizes of the input arrays are not identical, then let's throw an IllegalArgumentException with the message "studentIdList & studentsGrades are out-of-sync. studentIdList.length: " + studentIdList.length + ", studentsGrades.length: " + studentsGrades.length. You would just pass this message as-is to the IllegalArgumentException constructor and that way lengths of the two arrays are captured, which could be helpful to the programmer debugging this. In the code below, you can see the comments at the beginning of the method indicating the code you need to add. Such kind of parameter check done at the beginning of the method is referred to as parameter validation and is discussed later.

studentIdList = {1001, 1002}

studentsGrades = { { 'A', 'A', 'A', 'B' } }

Task 2: In this task, you will create a custom "checked" exception and will throw it from within calculateGPA. We know that a grade can be any of {'A', 'B', 'C'}. Let's now additionally assume that a grade can sometimes be unknown and let's represent it by whitespace ' '. If a student is not yet assigned a grade, then we need to throw an exception as GPAs must be computed only after all students have received grades. For this a new else if block has been added in the below code and you would throw an exception called MissingGradeException and pass it the student ID that is being processed in that iteration. So, you should also create a new MissingGradeException class that represents a checked exception and it should have a single attribute studentId and a getter getStudentId(). studentId can be initialized via constructor in MissingGradeException. Since it is a checked exception, you need to add other code necessary to avoid compilation errors including catching it in getStudentsByGPA.

Task 3: In this task, you will create a custom "unchecked" exception that would take a cause, i.e., you're implementing exception chaining. Think of getStudentsByGPA as a higher layer and calculateGPA that it invokes to be part of a lower layer. Since as per above task, calculateGPA can throw the checked exception MissingGradeException, you would catch it here and in its place re-throw another custom unchecked exception called InvalidDataException, but with the caught MissingGradeException added as the cause. InvalidDataException should include a chaining-aware constructor. When this exception gets generated, the programmer can also see the underlying cause.

Happy Coding!!

public class StudentUtil {    
    
    public static double[] calculateGPA(int[] studentIdList, char[][] studentsGrades) {
        // Your code: throw IllegalArgumentException with the message that lengths of input arrays are out-of-sync
                
        double[] gpaList = new double[studentIdList.length];
        
        for (int i = 0; i < studentsGrades.length; i++) {
            double gpa = 0.0;
            
            for (int j = 0; j < studentsGrades[i].length; j++) {
                if (studentsGrades[i][j] == 'A') {
                    gpa += 4.0;
                } else if (studentsGrades[i][j] == 'B') {
                    gpa += 3.0;
                } else if (studentsGrades[i][j] == 'C') {
                    gpa += 2.0;
                } else if (studentsGrades[i][j] == ' ') {
                    // student is yet to receive a grade
                    // Your code: throw checked exception MissingGradeException with student ID
                }
            }
            
            gpaList[i] = gpa/studentsGrades[i].length;
        }
        
        return gpaList;
    }    
    
     
    public static int[] getStudentsByGPA(double lower, double higher, int[] studentIdList, char[][] studentsGrades) {
        if (lower < 0 || higher < 0 || lower > higher) {
            return null;
        }
        
        double[] gpaList = new double[studentIdList.length];
        // Your code: catch MissingGradeException and re-throw runtime exception InvalidDataException initialized with the cause MissingGradeException
        gpaList = calculateGPA(studentIdList, studentsGrades);
       
        
        int count = 0;
        for (double gpa : gpaList) {
            if (gpa >= lower && gpa <= higher) {
                count++;
            }
        }
        
        int[] result = new int[count];
        int index = 0;
        for (int i = 0; i <  gpaList.length; i++) {
            if (gpaList[i] >= lower && gpaList[i] <= higher) {
                result[index++] = studentIdList[i];
            }
        }
        
        return result;
    }        
    
    
}